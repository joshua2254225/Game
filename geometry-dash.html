<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Geometry Dash â€“ ArcadeOwl</title>

<style>
html,body{
  margin:0;
  background:#000;
  overflow:hidden;
  font-family:system-ui,Arial;
}
canvas{
  display:block;
  margin:auto;
  background:linear-gradient(#0a0a14,#000);
}
#ui{
  position:fixed;
  top:10px;
  left:50%;
  transform:translateX(-50%);
  color:#fff;
  font-weight:700;
  text-align:center;
}
#ui span{margin:0 12px}
</style>
</head>

<body>

<div id="ui">
  <span>Score: <b id="score">0</b></span>
  <span>Best: <b id="best">0</b></span>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;

let score = 0;
let best = localStorage.getItem("gdBest") || 0;
document.getElementById("best").textContent = best;

const GRAVITY = 1.05;
const JUMP = -11;
let holding = false;
let gameOver = false;
let mode = "cube";

const player = {
  x: 120,
  y: canvas.height-140,
  size: 34,
  vy: 0
};

let groundY = canvas.height - 80;
let obstacles = [];
let frame = 0;
let spawnInterval = 120;

function spawnObstacle(){
  obstacles.push({
    x: canvas.width + 60,
    w: 40,
    h: 60
  });
}

function reset(){
  score = 0;
  mode = "cube";
  obstacles = [];
  player.y = groundY - player.size;
  player.vy = 0;
  gameOver = false;
}

function update(){
  if(gameOver) return;

  frame++;
  score++;
  document.getElementById("score").textContent = score;

  if(score > 1800) mode = "ship";

  // spawn
  if(frame % Math.max(80, spawnInterval - Math.floor(score/1200)) === 0){
    spawnObstacle();
  }

  // physics
  if(mode === "cube"){
    player.vy += GRAVITY;
    if(holding && player.vy < 0) player.vy -= 0.12;
  }else{
    if(holding) player.vy -= 0.6;
    else player.vy += 0.6;
  }

  player.y += player.vy;

  // ground
  if(player.y + player.size > groundY){
    player.y = groundY - player.size;
    player.vy = 0;
  }

  // obstacles
  obstacles.forEach(o=>o.x -= 6);
  obstacles = obstacles.filter(o=>o.x+o.w>0);

  // collision
  for(let o of obstacles){
    if(player.x < o.x+o.w &&
       player.x+player.size > o.x &&
       player.y+player.size > groundY-o.h){
      endGame();
    }
  }
}

function endGame(){
  gameOver = true;
  if(score > best){
    best = score;
    localStorage.setItem("gdBest",best);
    document.getElementById("best").textContent = best;
  }
  setTimeout(reset,1200);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // background pulse
  ctx.fillStyle = `hsl(${score/8%360},70%,10%)`;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // ground
  ctx.fillStyle="#222";
  ctx.fillRect(0,groundY,canvas.width,80);

  // player
  ctx.save();
  ctx.translate(player.x+player.size/2,player.y+player.size/2);
  ctx.rotate(mode==="cube" ? frame*0.05 : 0);
  ctx.fillStyle = mode==="cube" ? "#00f6ff" : "#ff00cc";
  ctx.shadowColor = ctx.fillStyle;
  ctx.shadowBlur = 20;
  ctx.fillRect(-player.size/2,-player.size/2,player.size,player.size);
  ctx.restore();

  // obstacles
  ctx.fillStyle="#ff0033";
  obstacles.forEach(o=>{
    ctx.fillRect(o.x,groundY-o.h,o.w,o.h);
  });
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

// input
addEventListener("keydown",e=>{
  if(e.code==="Space") holding=true;
});
addEventListener("keyup",e=>{
  if(e.code==="Space") holding=false;
});
canvas.addEventListener("touchstart",()=>holding=true);
canvas.addEventListener("touchend",()=>holding=false);

addEventListener("resize",()=>{
  canvas.width=innerWidth;
  canvas.height=innerHeight;
  groundY = canvas.height - 80;
});
</script>

</body>
</html>
