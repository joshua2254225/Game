<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Minesweeper ‚Äì ArcadeOwl</title>
<style>
:root{ --blue:#0b74de; --bg:#f5f7fb }
*{box-sizing:border-box}
body{margin:0;font-family:system-ui,Arial;background:var(--bg);color:#111}
.topbar{
  background:var(--blue);
  color:#fff;
  height:56px;
  display:flex;
  align-items:center;
  justify-content:center;
  position:relative;
  font-weight:800;
  font-size:20px;
}
.home{position:absolute;left:12px;text-decoration:none;color:white;font-size:20px;opacity:.8}
.wrap{max-width:980px;margin:18px auto;padding:12px}
.panel{background:#fff;border-radius:12px;padding:12px;box-shadow:0 8px 18px rgba(0,0,0,.06)}
.controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:10px}
select,button{padding:8px 12px;border-radius:8px;border:0;font-weight:700}
button{background:var(--blue);color:#fff;cursor:pointer}
.stats{display:flex;gap:12px;align-items:center;margin-bottom:8px;font-weight:700}
.info{color:#666;font-size:13px;margin-top:8px}
#boardWrap{
  width:100%;
  max-height:62vh;
  border-radius:10px;
  overflow:auto;
  background:linear-gradient(180deg,#e9f2fb,#ffffff);
  padding:8px;
  touch-action:none; /* we'll handle pointer dragging */
}
.board{
  display:grid;
  gap:6px;
  user-select:none;
  -webkit-user-select:none;
  -ms-user-select:none;
}
.cell{
  display:flex;
  align-items:center;
  justify-content:center;
  background:#d0d7e2;
  border-radius:6px;
  font-weight:800;
  font-size:16px;
  color:#111;
  width:36px;
  height:36px;
  cursor:pointer;
}
.cell.open{background:#eef1f6;cursor:default}
.cell.flag{background:#ffd166}
.cell.mine{background:#ff6b6b;color:#500}
.message{margin-top:10px;text-align:center;font-weight:800;font-size:18px}
@media (max-width:700px){
  .panel{padding:10px}
  #boardWrap{max-height:55vh}
}
</style>
</head>
<body>

<header class="topbar">
  <a class="home" href="index.html">‚Üê</a>
  ArcadeOwl ‚Äî Minesweeper
</header>

<main class="wrap">
  <div class="panel">
    <div class="controls">
      <label for="level">Level:</label>
      <select id="level">
        <option value="easy">Easy (8√ó8, 10 mines)</option>
        <option value="medium">Medium (12√ó12, 25 mines)</option>
        <option value="hard">Hard (16√ó16, 40 mines)</option>
      </select>

      <button id="newGameBtn">New Game</button>
      <button id="resetViewBtn">Center / Reset View</button>

      <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
        <div>‚è± <b id="time">0</b>s</div>
        <div>üö© <b id="flags">0</b></div>
      </div>
    </div>

    <div id="boardWrap" tabindex="0" aria-label="Minesweeper board container">
      <div id="board" class="board" role="grid"></div>
    </div>

    <div class="info">Tip: Left click / tap = open. Right click or long-press = flag. Drag the board to pan on mobile.</div>
    <div id="message" class="message"></div>
  </div>
</main>

<script>
/* Minesweeper improved:
 - flag bug fixed (works on all levels)
 - different cell sizes per level (Easy 36px, Medium 30px, Hard 24px)
 - pan/drag board container (pointer events)
 - right-click & long-press flag
 - timer/flags/messages
*/

const levelSelect = document.getElementById('level');
const newGameBtn = document.getElementById('newGameBtn');
const resetViewBtn = document.getElementById('resetViewBtn');
const boardWrap = document.getElementById('boardWrap');
const boardEl = document.getElementById('board');
const timeEl = document.getElementById('time');
const flagsEl = document.getElementById('flags');
const msgEl = document.getElementById('message');

let rows, cols, mines;
let board = []; // cells: {mine, open, flag, count}
let flags = 0;
let opened = 0;
let timer = 0;
let timerInt = null;
let gameOver = false;
let holdTimer = null;
let cellSize = 36;

/* level definitions */
const levels = {
  easy: {r:8, c:8, m:10, size:36},
  medium: {r:12, c:12, m:25, size:30},
  hard: {r:16, c:16, m:40, size:24}
};

/* utility */
function idx(x,y){ return y*cols + x; }

function startGame(){
  // clear timers / state
  clearInterval(timerInt);
  timer = 0;
  timeEl.textContent = 0;
  flags = 0;
  flagsEl.textContent = 0;
  opened = 0;
  gameOver = false;
  msgEl.textContent = '';

  const lvlKey = levelSelect.value;
  const lvl = levels[lvlKey];
  rows = lvl.r; cols = lvl.c; mines = lvl.m;
  cellSize = lvl.size;

  board = new Array(rows*cols).fill(0).map(()=>({mine:false,open:false,flag:false,count:0}));

  // place mines
  let placed = 0;
  while(placed < mines){
    const i = Math.floor(Math.random()*board.length);
    if(!board[i].mine){ board[i].mine = true; placed++; }
  }

  // compute numbers
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const i = idx(x,y);
      if(board[i].mine) continue;
      let cnt = 0;
      for(let dy=-1;dy<=1;dy++){
        for(let dx=-1;dx<=1;dx++){
          if(dx===0 && dy===0) continue;
          const nx = x+dx, ny = y+dy;
          if(nx>=0 && ny>=0 && nx<cols && ny<rows){
            if(board[idx(nx,ny)].mine) cnt++;
          }
        }
      }
      board[i].count = cnt;
    }
  }

  // build DOM grid
  boardEl.innerHTML = '';
  boardEl.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
  boardEl.style.gap = (cellSize>=32?6:4)+'px';
  for(let i=0;i<rows*cols;i++){
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.style.width = cellSize + 'px';
    cell.style.height = cellSize + 'px';
    cell.dataset.index = i;
    // unify pointer handlers for flag & open
    // prevent native context menu
    cell.addEventListener('contextmenu', (e)=> e.preventDefault());

    // pointerdown: start hold timer for long-press flag (touch)
    cell.addEventListener('pointerdown', (e)=>{
      cell.setPointerCapture(e.pointerId);
      // if right-click (button === 2) -> flag immediately (desktop)
      if(e.button === 2){
        toggleFlag(i);
        return;
      }
      // start long press timer for flag (500ms)
      holdTimer = setTimeout(()=>{
        toggleFlag(i);
        holdTimer = null;
      }, 500);
    });

    // pointerup: if holdTimer active => it was a short click => open
    cell.addEventListener('pointerup', (e)=>{
      // if holdTimer still exists, treat as click
      if(holdTimer){
        clearTimeout(holdTimer);
        holdTimer = null;
        openCell(i);
      }
      try{ cell.releasePointerCapture(e.pointerId); }catch(err){}
    });

    // pointercancel: cancel hold
    cell.addEventListener('pointercancel', ()=>{
      if(holdTimer){ clearTimeout(holdTimer); holdTimer = null; }
    });

    boardEl.appendChild(cell);
  }

  // reset view/scroll
  boardWrap.scrollLeft = 0;
  boardWrap.scrollTop = 0;

  // start timer
  timerInt = setInterval(()=>{
    timer++; timeEl.textContent = timer;
  },1000);
}

/* open cell */
function openCell(i){
  if(gameOver) return;
  const cellData = board[i];
  const el = boardEl.children[i];
  if(cellData.open || cellData.flag) return;
  cellData.open = true;
  el.classList.add('open');
  opened++;

  if(cellData.mine){
    el.classList.add('mine');
    el.textContent = 'üí£';
    revealAllMines();
    endGame(false);
    return;
  }

  if(cellData.count > 0){
    el.textContent = cellData.count;
  } else {
    // flood open neighbors
    const x = i % cols, y = Math.floor(i / cols);
    for(let dy=-1; dy<=1; dy++){
      for(let dx=-1; dx<=1; dx++){
        if(dx===0 && dy===0) continue;
        const nx = x+dx, ny = y+dy;
        if(nx>=0 && ny>=0 && nx<cols && ny<rows){
          const ni = idx(nx,ny);
          if(!board[ni].open) openCell(ni);
        }
      }
    }
  }

  if(opened === rows*cols - mines){
    endGame(true);
  }
}

/* toggle flag */
function toggleFlag(i){
  if(gameOver) return;
  const cellData = board[i];
  const el = boardEl.children[i];
  if(cellData.open) return;
  cellData.flag = !cellData.flag;
  if(cellData.flag){
    el.classList.add('flag'); el.textContent = 'üö©'; flags++;
  } else {
    el.classList.remove('flag'); el.textContent = ''; flags--;
  }
  flagsEl.textContent = flags;
}

/* reveal mines on lose */
function revealAllMines(){
  for(let i=0;i<board.length;i++){
    if(board[i].mine){
      const el = boardEl.children[i];
      el.classList.add('open','mine');
      el.textContent = 'üí£';
    }
  }
}

/* end game */
function endGame(win){
  gameOver = true;
  clearInterval(timerInt);
  msgEl.textContent = win ? 'üéâ You Win!' : 'üí• Game Over!';
}

/* PAN / DRAG FOR BOARDWRAP (mouse + touch) */
let isPanning = false;
let panStart = {x:0,y:0,scrollLeft:0,scrollTop:0};
boardWrap.addEventListener('pointerdown', (e)=>{
  // only start panning if pointer is not on a cell element that captured pointer
  // but we still allow pointerdown on boardWrap to pan
  isPanning = true;
  panStart.x = e.clientX;
  panStart.y = e.clientY;
  panStart.scrollLeft = boardWrap.scrollLeft;
  panStart.scrollTop = boardWrap.scrollTop;
  boardWrap.setPointerCapture(e.pointerId);
});
boardWrap.addEventListener('pointermove', (e)=>{
  if(!isPanning) return;
  const dx = e.clientX - panStart.x;
  const dy = e.clientY - panStart.y;
  boardWrap.scrollLeft = panStart.scrollLeft - dx;
  boardWrap.scrollTop = panStart.scrollTop - dy;
});
boardWrap.addEventListener('pointerup', (e)=>{
  isPanning = false;
  try{ boardWrap.releasePointerCapture(e.pointerId); }catch(e){}
});
boardWrap.addEventListener('pointercancel', ()=>{ isPanning = false; });

/* button handlers */
newGameBtn.addEventListener('click', ()=>{ startGame(); });
resetViewBtn.addEventListener('click', ()=>{
  boardWrap.scrollLeft = 0; boardWrap.scrollTop = 0;
});

/* initialize on load */
startGame();

/* Accessibility: prevent context menu on board for right-click convenience */
boardWrap.addEventListener('contextmenu', (e)=> e.preventDefault());
</script>

</body>
</html>
